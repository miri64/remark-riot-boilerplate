<!DOCTYPE html>
<html>
  <head>
    <title>How to be a Good Maintainer?</title>
    <meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="css/style.css">
    <style>
      blockquote {
        background-color: #1d1f21;
        margin: 30% 0;
      }
      blockquote p {
        font-size: 125%;
        padding: .5em;
        text-align: center;
      }
      #slide-outline > ol {
        font-size: 125%;
        line-height: 125%;
      }
      img {
        width: 75%;
      }
    </style>
  </head>
  <body>
    <textarea id="source">

name: title-slide
class: middle center

# How to be a Good Maintainer?
## Martine Lenders ([@miri64](https://github.com/miri64))
## Hauke Petersen ([@haukepetersen](https://github.com/haukepetersen))

---

name: outline

# Outline

1. Introduction
2. Maintainer Guidelines
3. Interaction
4. Discussion

---

# Introduction

* Goal: Make us all better maintainer
  - Find minimum maintaining standards
* Main objective of a maintainer: *Quality* assurance (review)
  - *Code* Quality
  - *Functionality*
  - *Non-functional* qualities
* Second objective: Help out contributors with their problems

---

# Maintainer Guidelines

* [Maintainer Guidelines @ GitHub Repo](https://ogithub.com/RIOT-OS/RIOT/blob/master/MAINTAINING.md)
* Follow them step by step (skip steps if clearly unnecessary):

  1. Fundamentals
  2. Code design
  3. Testing
  4. Coding conventions
  5. Documentation

* Can always be adapted via PR (requires 2 ACKs!)

---

# 1. Fundamentals

1. Question the reasoning of the PR for yourself and in discussion with the
   contributor
--

2. Simplest solution possible?
--

3. Should the PR be split?
--

4. High-level design?
--

5. Does it make sense?
--

6. In conflict to existing concepts?
--

7. Is it's structure valid
--

8. Test descriptions or tests provided?
--

9. Code compiles
--

10. Rights of previous authors respected?
--

11. Duplicate?

---

# 2. Code design

1. Code duplication
--

2. Memory usage
--

3. Check all code paths
--

4. API compliance
--

5. Consistency of error handling
--

6. Variable and function scope
--

7. Syntactical, semantical, or logical errors
--

8. Runtime efficiency
--

9. Simplicity of code design

---

# 3. Testing

- Run tests on native (if applicable) + few selected boards
- Follow testing instructions given by PR (see 1.8)

> Challenge them, be creative, try to break it üòâ

---

# The last mile

### 4. Coding conventions
- Can be *aided* by tools like `uncrustify` or `vera++`

--

### 5. Documentation
1. Module documentation
2. Function-level documentation
3. Understandable?
4. Grammar and spelling mistakes

---

# Interaction

* Be *responsive*, be *helpful*, be *friendly*
    - (See our [Code of Conduct](https://github.com/RIOT-OS/RIOT/blob/master/CODE_OF_CONDUCT.md))
* Ask other maintainers for help for parts you don't know about
* Mark in your ACK what you ACK'd

---

class: middle center

# Let's discuss!

???

- might go a little ahead of maintainer plenum
- Hauke's little rant-corner ;-)

---

class: middle center

# Efficiency vs. Beginner friendliness
## Industry-grade Arduino?

???

- contradicting goal: industry grade OS but also beginner friendly as 
e.g. Arduino
- memory usage follows saw-tooth pattern, with an overall increasing 
trend -> 8 bytes here, 24 bytes there, all minor but adding up

Examples:
- `netdev` discussion: additional function pointers vs. function overloading
- board configuration (`periph_conf.h`): define base concept easier to 
use, but did not scale

-> make sure the impacts are well understood: i.e. code size and 
runtime! benchmarks

---

class: middle center

# Fuzzy RIOT
## Are we killing the developers's creative freedom?

???

- style, structure, processes: tight rules in RIOT that have to be followed
- why? -> maintainability, but also common look-and-feel
But:
- every programmer has his/her own ways to approach a problem!
- hypothesis: a certain amount of personal 'handwriting' has no impact 
on maintainability

Goal:
- speed up review process

Solution: Staging?!

Examples:
- naming of modules: only have minimum compliance rules (e.g. don't use 
completely missleading names)
- does it really matter if there is 1 or 2 blank lines e.g. between the 
last `#inlcude` and the first function def?
- most of us are no native speakers, so do we want to give the 
spelling/grammar/wording comments multiple iterations even if it is 
clear what they mean in the first place?

---

class: middle center

# ‚ÄúAcademic Problem‚Äù
## Judging the practical impact

???

- we have seen long and time-consuming discussions about problems which 
exist on paper but with minor impact in practice
- problem: hard to tell in times
- perfectionism: 95%-5% rule, development time inverse proportional to 
progress
- proposal: judge practical impact of issues and adapt priority accordingly
- don't get caught up in 'low-impact' discussions

Examples:
- re-factoring hell: change a module name every week just because one 
likes the new name better...
- priority inversion: well known problem in the space of real-time 
systems, but does it really have a big impact on typical RIOT usage 
scenarios?,

    </textarea>
    <script src="js/remark-0.14.0.min.js">
    </script>
    <script>
      var slideshow = remark.create({ highlightStyle: "tomorrow-night" });
    </script>
  </body>
</html>
